`timescale 1ns / 100ps

`define	NumBits	16
`define	FUNC_ADD	4'b0000
`define	FUNC_SUB	4'b0001
`define FUNC_ID 	4'b0010
`define FUNC_NOT	4'b0011
`define	FUNC_AND	4'b0100
`define	FUNC_OR 	4'b0101
`define	FUNC_NAND	4'b0110
`define	FUNC_NOR	4'b0111
`define FUNC_XOR	4'b1000
`define FUNC_XNOR	4'b1001
`define	FUNC_LLS	4'b1010
`define	FUNC_LRS	4'b1011
`define	FUNC_ALS	4'b1100
`define	FUNC_ARS	4'b1101
`define	FUNC_TCP	4'b1110
`define	FUNC_ZERO	4'b1111

module ALU (A, B, FuncCode, C, OverflowFlag);
	input [`NumBits-1:0] A;
	input [`NumBits-1:0] B;
	input [3:0] FuncCode;
	output [`NumBits-1:0] C;
	output OverflowFlag;

	reg [`NumBits-1:0] C;
	reg OverflowFlag;

	// You can declare any variables as needed.
	/*
		YOUR VARIABLE DECLARATION...
	*/

	initial begin
		C = 0;
		OverflowFlag = 0;
	end   	
	
	always @(A or B or FuncCode) begin
		case(FuncCode)
			FUNC_ADD: ;
			FUNC_SUB: ;
			FUNC_ID: C <= A;
			FUNC_NOT: C <= ~A;
			FUNC_AND: C <= A & B;
			FUNC_OR: C <= A | B;
			FUNC_NAND: C <= ~(A & B);
			FUNC_NOR: C <= ~(A | B);
			FUNC_XOR: C <= A ^ B;
			FUNC_XNOR: C <= A ~^ B;
			FUNC_LLS: C <= A << 1;
			FUNC_LRS: C <= A >> 1;
			FUNC_ALS: C <= A <<< 1;
			FUNC_ARS: C <= A >>> 1;
			FUNC_TCP: ;
			FUNC_ZERO: ;
		endcase
	end
	// TODO: You should implement the functionality of ALU!
	// (HINT: Use 'always @(...) begin ... end')
	/*
		YOUR ALU FUNCTIONALITY IMPLEMENTATION...
	*/

endmodule

